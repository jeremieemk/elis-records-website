{"version":3,"file":"static/development/pages/_app.js","sources":["webpack:///./node_modules/@babel/runtime-corejs2/regenerator/index.js","webpack:///./node_modules/cross-fetch/dist/browser-ponyfill.js","webpack:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js","webpack:///./node_modules/prismic-javascript/esm/prismic-javascript.mjs","webpack:///delegated ./node_modules/react/index.js from dll-reference dll_ef0ff7c60362f24a921f","webpack:///./node_modules/regenerator-runtime/runtime.js","webpack:///./pages/_app.js","webpack:///external \"dll_ef0ff7c60362f24a921f\""],"sourcesContent":["module.exports = require(\"regenerator-runtime\");\n","var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n","\n    (window.__NEXT_P=window.__NEXT_P||[]).push([\"/_app\", function() {\n      var mod = require(\"private-next-pages/_app.js\")\n      if(module.hot) {\n        module.hot.accept(\"private-next-pages/_app.js\", function() {\n          if(!next.router.components[\"/_app\"]) return\n          var updatedPage = require(\"private-next-pages/_app.js\")\n          next.router.update(\"/_app\", updatedPage)\n        })\n      }\n      return mod\n    }]);\n  ","import crossFetch from 'cross-fetch';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar Variation = /** @class */ (function () {\n    function Variation(data) {\n        this.data = {};\n        this.data = data;\n    }\n    Variation.prototype.id = function () {\n        return this.data.id;\n    };\n    Variation.prototype.ref = function () {\n        return this.data.ref;\n    };\n    Variation.prototype.label = function () {\n        return this.data.label;\n    };\n    return Variation;\n}());\nvar Experiment = /** @class */ (function () {\n    function Experiment(data) {\n        this.data = {};\n        this.data = data;\n        this.variations = (data.variations || []).map(function (v) {\n            return new Variation(v);\n        });\n    }\n    Experiment.prototype.id = function () {\n        return this.data.id;\n    };\n    Experiment.prototype.googleId = function () {\n        return this.data.googleId;\n    };\n    Experiment.prototype.name = function () {\n        return this.data.name;\n    };\n    return Experiment;\n}());\nvar Experiments = /** @class */ (function () {\n    function Experiments(data) {\n        if (data) {\n            this.drafts = (data.drafts || []).map(function (exp) {\n                return new Experiment(exp);\n            });\n            this.running = (data.running || []).map(function (exp) {\n                return new Experiment(exp);\n            });\n        }\n    }\n    Experiments.prototype.current = function () {\n        if (this.running.length > 0) {\n            return this.running[0];\n        }\n        else {\n            return null;\n        }\n    };\n    Experiments.prototype.refFromCookie = function (cookie) {\n        if (!cookie || cookie.trim() === '')\n            return null;\n        var splitted = cookie.trim().split(' ');\n        if (splitted.length < 2)\n            return null;\n        var expId = splitted[0];\n        var varIndex = parseInt(splitted[1], 10);\n        var exp = this.running.filter(function (exp) {\n            return exp.googleId() === expId && exp.variations.length > varIndex;\n        })[0];\n        return exp ? exp.variations[varIndex].ref() : null;\n    };\n    return Experiments;\n}());\n\nvar LazySearchForm = /** @class */ (function () {\n    function LazySearchForm(id, api) {\n        this.id = id;\n        this.api = api;\n        this.fields = {};\n    }\n    LazySearchForm.prototype.set = function (key, value) {\n        this.fields[key] = value;\n        return this;\n    };\n    LazySearchForm.prototype.ref = function (ref) {\n        return this.set('ref', ref);\n    };\n    LazySearchForm.prototype.query = function (query) {\n        return this.set('q', query);\n    };\n    LazySearchForm.prototype.pageSize = function (size) {\n        return this.set('pageSize', size);\n    };\n    LazySearchForm.prototype.fetch = function (fields) {\n        console.warn('Warning: Using Fetch is deprecated. Use the property `graphQuery` instead.');\n        return this.set('fetch', fields);\n    };\n    LazySearchForm.prototype.fetchLinks = function (fields) {\n        console.warn('Warning: Using FetchLinks is deprecated. Use the property `graphQuery` instead.');\n        return this.set('fetchLinks', fields);\n    };\n    LazySearchForm.prototype.graphQuery = function (query) {\n        return this.set('graphQuery', query);\n    };\n    LazySearchForm.prototype.lang = function (langCode) {\n        return this.set('lang', langCode);\n    };\n    LazySearchForm.prototype.page = function (p) {\n        return this.set('page', p);\n    };\n    LazySearchForm.prototype.after = function (documentId) {\n        return this.set('after', documentId);\n    };\n    LazySearchForm.prototype.orderings = function (orderings) {\n        return this.set('orderings', orderings);\n    };\n    LazySearchForm.prototype.url = function () {\n        var _this = this;\n        return this.api.get().then(function (api) {\n            return LazySearchForm.toSearchForm(_this, api).url();\n        });\n    };\n    LazySearchForm.prototype.submit = function (cb) {\n        var _this = this;\n        return this.api.get().then(function (api) {\n            return LazySearchForm.toSearchForm(_this, api).submit(cb);\n        });\n    };\n    LazySearchForm.toSearchForm = function (lazyForm, api) {\n        var form = api.form(lazyForm.id);\n        if (form) {\n            return Object.keys(lazyForm.fields).reduce(function (form, fieldKey) {\n                var fieldValue = lazyForm.fields[fieldKey];\n                if (fieldKey === 'q') {\n                    return form.query(fieldValue);\n                }\n                else if (fieldKey === 'pageSize') {\n                    return form.pageSize(fieldValue);\n                }\n                else if (fieldKey === 'fetch') {\n                    return form.fetch(fieldValue);\n                }\n                else if (fieldKey === 'fetchLinks') {\n                    return form.fetchLinks(fieldValue);\n                }\n                else if (fieldKey === 'graphQuery') {\n                    return form.graphQuery(fieldValue);\n                }\n                else if (fieldKey === 'lang') {\n                    return form.lang(fieldValue);\n                }\n                else if (fieldKey === 'page') {\n                    return form.page(fieldValue);\n                }\n                else if (fieldKey === 'after') {\n                    return form.after(fieldValue);\n                }\n                else if (fieldKey === 'orderings') {\n                    return form.orderings(fieldValue);\n                }\n                else {\n                    return form.set(fieldKey, fieldValue);\n                }\n            }, form);\n        }\n        else {\n            throw new Error(\"Unable to access to form \" + lazyForm.id);\n        }\n    };\n    return LazySearchForm;\n}());\nvar SearchForm = /** @class */ (function () {\n    function SearchForm(form, httpClient) {\n        this.httpClient = httpClient;\n        this.form = form;\n        this.data = {};\n        for (var field in form.fields) {\n            if (form.fields[field]['default']) {\n                this.data[field] = [form.fields[field]['default']];\n            }\n        }\n    }\n    SearchForm.prototype.set = function (field, value) {\n        var fieldDesc = this.form.fields[field];\n        if (!fieldDesc)\n            throw new Error('Unknown field ' + field);\n        var checkedValue = value === '' || value === undefined ? null : value;\n        var values = this.data[field] || [];\n        if (fieldDesc.multiple) {\n            values = checkedValue ? values.concat([checkedValue]) : values;\n        }\n        else {\n            values = checkedValue ? [checkedValue] : values;\n        }\n        this.data[field] = values;\n        return this;\n    };\n    /**\n     * Sets a ref to query on for this SearchForm. This is a mandatory\n     * method to call before calling submit(), and api.form('everything').submit()\n     * will not work.\n     */\n    SearchForm.prototype.ref = function (ref) {\n        return this.set('ref', ref);\n    };\n    /**\n     * Sets a predicate-based query for this SearchForm. This is where you\n     * paste what you compose in your prismic.io API browser.\n     */\n    SearchForm.prototype.query = function (query) {\n        if (typeof query === 'string') {\n            return this.query([query]);\n        }\n        else if (Array.isArray(query)) {\n            return this.set('q', \"[\" + query.join('') + \"]\");\n        }\n        else {\n            throw new Error(\"Invalid query : \" + query);\n        }\n    };\n    /**\n     * Sets a page size to query for this SearchForm. This is an optional method.\n     *\n     * @param {number} size - The page size\n     * @returns {SearchForm} - The SearchForm itself\n     */\n    SearchForm.prototype.pageSize = function (size) {\n        return this.set('pageSize', size);\n    };\n    /**\n     * Restrict the results document to the specified fields\n     */\n    SearchForm.prototype.fetch = function (fields) {\n        console.warn('Warning: Using Fetch is deprecated. Use the property `graphQuery` instead.');\n        var strFields = Array.isArray(fields) ? fields.join(',') : fields;\n        return this.set('fetch', strFields);\n    };\n    /**\n     * Include the requested fields in the DocumentLink instances in the result\n     */\n    SearchForm.prototype.fetchLinks = function (fields) {\n        console.warn('Warning: Using FetchLinks is deprecated. Use the property `graphQuery` instead.');\n        var strFields = Array.isArray(fields) ? fields.join(',') : fields;\n        return this.set('fetchLinks', strFields);\n    };\n    /**\n     * Sets the graphquery to query for this SearchForm. This is an optional method.\n     */\n    SearchForm.prototype.graphQuery = function (query) {\n        return this.set('graphQuery', query);\n    };\n    /**\n     * Sets the language to query for this SearchForm. This is an optional method.\n     */\n    SearchForm.prototype.lang = function (langCode) {\n        return this.set('lang', langCode);\n    };\n    /**\n     * Sets the page number to query for this SearchForm. This is an optional method.\n     */\n    SearchForm.prototype.page = function (p) {\n        return this.set('page', p);\n    };\n    /**\n     * Remove all the documents except for those after the specified document in the list. This is an optional method.\n     */\n    SearchForm.prototype.after = function (documentId) {\n        return this.set('after', documentId);\n    };\n    /**\n     * Sets the orderings to query for this SearchForm. This is an optional method.\n     */\n    SearchForm.prototype.orderings = function (orderings) {\n        if (!orderings) {\n            return this;\n        }\n        else {\n            return this.set('orderings', \"[\" + orderings.join(',') + \"]\");\n        }\n    };\n    /**\n     * Build the URL to query\n     */\n    SearchForm.prototype.url = function () {\n        var url = this.form.action;\n        if (this.data) {\n            var sep = (url.indexOf('?') > -1 ? '&' : '?');\n            for (var key in this.data) {\n                if (Object.prototype.hasOwnProperty.call(this.data, key)) {\n                    var values = this.data[key];\n                    if (values) {\n                        for (var i = 0; i < values.length; i++) {\n                            url += sep + key + '=' + encodeURIComponent(values[i]);\n                            sep = '&';\n                        }\n                    }\n                }\n            }\n        }\n        return url;\n    };\n    /**\n     * Submits the query, and calls the callback function.\n     */\n    SearchForm.prototype.submit = function (cb) {\n        return this.httpClient.cachedRequest(this.url()).then(function (response) {\n            cb && cb(null, response);\n            return response;\n        }).catch(function (error) {\n            cb && cb(error);\n            throw error;\n        });\n    };\n    return SearchForm;\n}());\n\nvar OPERATOR = {\n    at: 'at',\n    not: 'not',\n    missing: 'missing',\n    has: 'has',\n    any: 'any',\n    in: 'in',\n    fulltext: 'fulltext',\n    similar: 'similar',\n    numberGt: 'number.gt',\n    numberLt: 'number.lt',\n    numberInRange: 'number.inRange',\n    dateBefore: 'date.before',\n    dateAfter: 'date.after',\n    dateBetween: 'date.between',\n    dateDayOfMonth: 'date.day-of-month',\n    dateDayOfMonthAfter: 'date.day-of-month-after',\n    dateDayOfMonthBefore: 'date.day-of-month-before',\n    dateDayOfWeek: 'date.day-of-week',\n    dateDayOfWeekAfter: 'date.day-of-week-after',\n    dateDayOfWeekBefore: 'date.day-of-week-before',\n    dateMonth: 'date.month',\n    dateMonthBefore: 'date.month-before',\n    dateMonthAfter: 'date.month-after',\n    dateYear: 'date.year',\n    dateHour: 'date.hour',\n    dateHourBefore: 'date.hour-before',\n    dateHourAfter: 'date.hour-after',\n    GeopointNear: 'geopoint.near',\n};\nfunction encode(value) {\n    if (typeof value === 'string') {\n        return \"\\\"\" + value + \"\\\"\";\n    }\n    else if (typeof value === 'number') {\n        return value.toString();\n    }\n    else if (value instanceof Date) {\n        return value.getTime().toString();\n    }\n    else if (Array.isArray(value)) {\n        return \"[\" + value.map(function (v) { return encode(v); }).join(',') + \"]\";\n    }\n    else if (typeof value === \"boolean\") {\n        return value.toString();\n    }\n    else {\n        throw new Error(\"Unable to encode \" + value + \" of type \" + typeof value);\n    }\n}\nvar geopoint = {\n    near: function (fragment, latitude, longitude, radius) {\n        return \"[\" + OPERATOR.GeopointNear + \"(\" + fragment + \", \" + latitude + \", \" + longitude + \", \" + radius + \")]\";\n    },\n};\nvar date = {\n    before: function (fragment, before) {\n        return \"[\" + OPERATOR.dateBefore + \"(\" + fragment + \", \" + encode(before) + \")]\";\n    },\n    after: function (fragment, after) {\n        return \"[\" + OPERATOR.dateAfter + \"(\" + fragment + \", \" + encode(after) + \")]\";\n    },\n    between: function (fragment, before, after) {\n        return \"[\" + OPERATOR.dateBetween + \"(\" + fragment + \", \" + encode(before) + \", \" + encode(after) + \")]\";\n    },\n    dayOfMonth: function (fragment, day) {\n        return \"[\" + OPERATOR.dateDayOfMonth + \"(\" + fragment + \", \" + day + \")]\";\n    },\n    dayOfMonthAfter: function (fragment, day) {\n        return \"[\" + OPERATOR.dateDayOfMonthAfter + \"(\" + fragment + \", \" + day + \")]\";\n    },\n    dayOfMonthBefore: function (fragment, day) {\n        return \"[\" + OPERATOR.dateDayOfMonthBefore + \"(\" + fragment + \", \" + day + \")]\";\n    },\n    dayOfWeek: function (fragment, day) {\n        return \"[\" + OPERATOR.dateDayOfWeek + \"(\" + fragment + \", \" + encode(day) + \")]\";\n    },\n    dayOfWeekAfter: function (fragment, day) {\n        return \"[\" + OPERATOR.dateDayOfWeekAfter + \"(\" + fragment + \", \" + encode(day) + \")]\";\n    },\n    dayOfWeekBefore: function (fragment, day) {\n        return \"[\" + OPERATOR.dateDayOfWeekBefore + \"(\" + fragment + \", \" + encode(day) + \")]\";\n    },\n    month: function (fragment, month) {\n        return \"[\" + OPERATOR.dateMonth + \"(\" + fragment + \", \" + encode(month) + \")]\";\n    },\n    monthBefore: function (fragment, month) {\n        return \"[\" + OPERATOR.dateMonthBefore + \"(\" + fragment + \", \" + encode(month) + \")]\";\n    },\n    monthAfter: function (fragment, month) {\n        return \"[\" + OPERATOR.dateMonthAfter + \"(\" + fragment + \", \" + encode(month) + \")]\";\n    },\n    year: function (fragment, year) {\n        return \"[\" + OPERATOR.dateYear + \"(\" + fragment + \", \" + year + \")]\";\n    },\n    hour: function (fragment, hour) {\n        return \"[\" + OPERATOR.dateHour + \"(\" + fragment + \", \" + hour + \")]\";\n    },\n    hourBefore: function (fragment, hour) {\n        return \"[\" + OPERATOR.dateHourBefore + \"(\" + fragment + \", \" + hour + \")]\";\n    },\n    hourAfter: function (fragment, hour) {\n        return \"[\" + OPERATOR.dateHourAfter + \"(\" + fragment + \", \" + hour + \")]\";\n    },\n};\nvar number = {\n    gt: function (fragment, value) {\n        return \"[\" + OPERATOR.numberGt + \"(\" + fragment + \", \" + value + \")]\";\n    },\n    lt: function (fragment, value) {\n        return \"[\" + OPERATOR.numberLt + \"(\" + fragment + \", \" + value + \")]\";\n    },\n    inRange: function (fragment, before, after) {\n        return \"[\" + OPERATOR.numberInRange + \"(\" + fragment + \", \" + before + \", \" + after + \")]\";\n    },\n};\nvar Predicates = {\n    at: function (fragment, value) {\n        return \"[\" + OPERATOR.at + \"(\" + fragment + \", \" + encode(value) + \")]\";\n    },\n    not: function (fragment, value) {\n        return \"[\" + OPERATOR.not + \"(\" + fragment + \", \" + encode(value) + \")]\";\n    },\n    missing: function (fragment) {\n        return \"[\" + OPERATOR.missing + \"(\" + fragment + \")]\";\n    },\n    has: function (fragment) {\n        return \"[\" + OPERATOR.has + \"(\" + fragment + \")]\";\n    },\n    any: function (fragment, values) {\n        return \"[\" + OPERATOR.any + \"(\" + fragment + \", \" + encode(values) + \")]\";\n    },\n    in: function (fragment, values) {\n        return \"[\" + OPERATOR.in + \"(\" + fragment + \", \" + encode(values) + \")]\";\n    },\n    fulltext: function (fragment, value) {\n        return \"[\" + OPERATOR.fulltext + \"(\" + fragment + \", \" + encode(value) + \")]\";\n    },\n    similar: function (documentId, maxResults) {\n        return \"[\" + OPERATOR.similar + \"(\\\"\" + documentId + \"\\\", \" + maxResults + \")]\";\n    },\n    date: date,\n    dateBefore: date.before,\n    dateAfter: date.after,\n    dateBetween: date.between,\n    dayOfMonth: date.dayOfMonth,\n    dayOfMonthAfter: date.dayOfMonthAfter,\n    dayOfMonthBefore: date.dayOfMonthBefore,\n    dayOfWeek: date.dayOfWeek,\n    dayOfWeekAfter: date.dayOfWeekAfter,\n    dayOfWeekBefore: date.dayOfWeekBefore,\n    month: date.month,\n    monthBefore: date.monthBefore,\n    monthAfter: date.monthAfter,\n    year: date.year,\n    hour: date.hour,\n    hourBefore: date.hourBefore,\n    hourAfter: date.hourAfter,\n    number: number,\n    gt: number.gt,\n    lt: number.lt,\n    inRange: number.inRange,\n    near: geopoint.near,\n    geopoint: geopoint,\n};\n\n/* eslint-disable */\n// Some portions of code from https://github.com/jshttp/cookie\nvar decode = decodeURIComponent;\nfunction tryDecode(str, decode) {\n    try {\n        return decode(str);\n    }\n    catch (e) {\n        return str;\n    }\n}\nfunction parse(str, options) {\n    if (typeof str !== 'string') {\n        throw new TypeError('argument str must be a string');\n    }\n    var obj = {};\n    var opt = options || {};\n    var pairs = str.split(/; */);\n    var dec = opt.decode || decode;\n    pairs.forEach(function (pair) {\n        var eq_idx = pair.indexOf('=');\n        // skip things that don't look like key=value\n        if (eq_idx < 0) {\n            return;\n        }\n        var key = pair.substr(0, eq_idx).trim();\n        var val = pair.substr(++eq_idx, pair.length).trim();\n        // quoted values\n        if ('\"' == val[0]) {\n            val = val.slice(1, -1);\n        }\n        // only assign once\n        if (undefined == obj[key]) {\n            obj[key] = tryDecode(val, dec);\n        }\n    });\n    return obj;\n}\nvar Cookies = { parse: parse };\n\nfunction createPreviewResolver(token, documentId, getDocByID) {\n    var resolve = function (linkResolver, defaultUrl, cb) {\n        if (documentId && getDocByID) {\n            return getDocByID(documentId, { ref: token }).then(function (document) {\n                if (!document) {\n                    cb && cb(null, defaultUrl);\n                    return defaultUrl;\n                }\n                else {\n                    var url = (linkResolver && linkResolver(document)) || document.url || defaultUrl;\n                    cb && cb(null, url);\n                    return url;\n                }\n            });\n        }\n        else {\n            return Promise.resolve(defaultUrl);\n        }\n    };\n    return { token: token, documentId: documentId, resolve: resolve };\n}\n\nvar PREVIEW_COOKIE = 'io.prismic.preview';\nvar EXPERIMENT_COOKIE = 'io.prismic.experiment';\nvar ResolvedApi = /** @class */ (function () {\n    function ResolvedApi(data, httpClient, options) {\n        this.data = data;\n        this.masterRef = data.refs.filter(function (ref) { return ref.isMasterRef; })[0];\n        this.experiments = new Experiments(data.experiments);\n        this.bookmarks = data.bookmarks;\n        this.httpClient = httpClient;\n        this.options = options;\n        this.refs = data.refs;\n        this.tags = data.tags;\n        this.types = data.types;\n        this.languages = data.languages;\n    }\n    /**\n     * Returns a useable form from its id, as described in the RESTful description of the API.\n     * For instance: api.form(\"everything\") works on every repository (as \"everything\" exists by default)\n     * You can then chain the calls: api.form(\"everything\").query('[[:d = at(document.id, \"UkL0gMuvzYUANCpf\")]]').ref(ref).submit()\n     */\n    ResolvedApi.prototype.form = function (formId) {\n        var form = this.data.forms[formId];\n        if (form) {\n            return new SearchForm(form, this.httpClient);\n        }\n        return null;\n    };\n    ResolvedApi.prototype.everything = function () {\n        var f = this.form('everything');\n        if (!f)\n            throw new Error('Missing everything form');\n        return f;\n    };\n    /**\n     * The ID of the master ref on this prismic.io API.\n     * Do not use like this: searchForm.ref(api.master()).\n     * Instead, set your ref once in a variable, and call it when you need it; this will allow to change the ref you're viewing easily for your entire page.\n     */\n    ResolvedApi.prototype.master = function () {\n        return this.masterRef.ref;\n    };\n    /**\n     * Returns the ref ID for a given ref's label.\n     * Do not use like this: searchForm.ref(api.ref(\"Future release label\")).\n     * Instead, set your ref once in a variable, and call it when you need it; this will allow to change the ref you're viewing easily for your entire page.\n     */\n    ResolvedApi.prototype.ref = function (label) {\n        var ref = this.data.refs.filter(function (ref) { return ref.label === label; })[0];\n        return ref ? ref.ref : null;\n    };\n    ResolvedApi.prototype.currentExperiment = function () {\n        return this.experiments.current();\n    };\n    /**\n     * Query the repository\n     */\n    ResolvedApi.prototype.query = function (q, optionsOrCallback, cb) {\n        if (cb === void 0) { cb = function () { }; }\n        var _a = typeof optionsOrCallback === 'function'\n            ? { options: {}, callback: optionsOrCallback }\n            : { options: optionsOrCallback || {}, callback: cb }, options = _a.options, callback = _a.callback;\n        var form = this.everything();\n        for (var key in options) {\n            form = form.set(key, options[key]);\n        }\n        if (!options.ref) {\n            // Look in cookies if we have a ref (preview or experiment)\n            var cookieString = '';\n            if (this.options.req) { // NodeJS\n                cookieString = this.options.req.headers['cookie'] || '';\n            }\n            else if (typeof window !== 'undefined' && window.document) { // Browser\n                cookieString = window.document.cookie || '';\n            }\n            var cookies = Cookies.parse(cookieString);\n            var previewRef = cookies[PREVIEW_COOKIE];\n            var experimentRef = this.experiments.refFromCookie(cookies[EXPERIMENT_COOKIE]);\n            form = form.ref(previewRef || experimentRef || this.masterRef.ref);\n        }\n        if (q) {\n            form.query(q);\n        }\n        return form.submit(callback);\n    };\n    /**\n     * Retrieve the document returned by the given query\n     * @param {string|array|Predicate} the query\n     * @param {object} additional parameters. In NodeJS, pass the request as 'req'.\n     * @param {function} callback(err, doc)\n     */\n    ResolvedApi.prototype.queryFirst = function (q, optionsOrCallback, cb) {\n        var _a = typeof optionsOrCallback === 'function'\n            ? { options: {}, callback: optionsOrCallback }\n            : { options: optionsOrCallback || {}, callback: cb || (function () { }) }, options = _a.options, callback = _a.callback;\n        options.page = 1;\n        options.pageSize = 1;\n        return this.query(q, options).then(function (response) {\n            var document = response && response.results && response.results[0];\n            callback(null, document);\n            return document;\n        }).catch(function (error) {\n            callback(error);\n            throw error;\n        });\n    };\n    /**\n     * Retrieve the document with the given id\n     */\n    ResolvedApi.prototype.getByID = function (id, maybeOptions, cb) {\n        var options = maybeOptions ? __assign({}, maybeOptions) : {};\n        if (!options.lang)\n            options.lang = '*';\n        return this.queryFirst(Predicates.at('document.id', id), options, cb);\n    };\n    /**\n     * Retrieve multiple documents from an array of id\n     */\n    ResolvedApi.prototype.getByIDs = function (ids, maybeOptions, cb) {\n        var options = maybeOptions ? __assign({}, maybeOptions) : {};\n        if (!options.lang)\n            options.lang = '*';\n        return this.query(Predicates.in('document.id', ids), options, cb);\n    };\n    /**\n     * Retrieve the document with the given uid\n     */\n    ResolvedApi.prototype.getByUID = function (type, uid, maybeOptions, cb) {\n        var options = maybeOptions ? __assign({}, maybeOptions) : {};\n        if (options.lang === '*')\n            throw new Error(\"FORBIDDEN. You can't use getByUID with *, use the predicates instead.\");\n        if (!options.page)\n            options.page = 1;\n        return this.queryFirst(Predicates.at(\"my.\" + type + \".uid\", uid), options, cb);\n    };\n    /**\n     * Retrieve the singleton document with the given type\n     */\n    ResolvedApi.prototype.getSingle = function (type, maybeOptions, cb) {\n        var options = maybeOptions ? __assign({}, maybeOptions) : {};\n        return this.queryFirst(Predicates.at('document.type', type), options, cb);\n    };\n    /**\n     * Retrieve the document with the given bookmark\n     */\n    ResolvedApi.prototype.getBookmark = function (bookmark, maybeOptions, cb) {\n        var id = this.data.bookmarks[bookmark];\n        if (id) {\n            return this.getByID(id, maybeOptions, cb);\n        }\n        else {\n            return Promise.reject('Error retrieving bookmarked id');\n        }\n    };\n    ResolvedApi.prototype.getPreviewResolver = function (token, documentId) {\n        return createPreviewResolver(token, documentId, this.getByID.bind(this));\n    };\n    ResolvedApi.prototype.previewSession = function (token, linkResolver, defaultUrl, cb) {\n        var _this = this;\n        console.warn('previewSession function is deprecated in favor of getPreviewResolver function.');\n        return new Promise(function (resolve, reject) {\n            _this.httpClient.request(token, function (e, result) {\n                if (e) {\n                    cb && cb(e);\n                    reject(e);\n                }\n                else if (result) {\n                    if (!result.mainDocument) {\n                        cb && cb(null, defaultUrl);\n                        resolve(defaultUrl);\n                    }\n                    else {\n                        return _this.getByID(result.mainDocument, { ref: token }).then(function (document) {\n                            if (!document) {\n                                cb && cb(null, defaultUrl);\n                                resolve(defaultUrl);\n                            }\n                            else {\n                                var url = (linkResolver && linkResolver(document)) || document.url || defaultUrl;\n                                cb && cb(null, url);\n                                resolve(url);\n                            }\n                        }).catch(reject);\n                    }\n                }\n            });\n        });\n    };\n    return ResolvedApi;\n}());\n\n/* eslint-disable */\n/**\n* A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n* recently used items while discarding least recently used items when its limit\n* is reached.\n*\n* Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n* Typescript-ified by Oleksandr Nikitin <https://tvori.info>\n*\n* Illustration of the design:\n*\n*       entry             entry             entry             entry\n*       ______            ______            ______            ______\n*      | head |.newer => |      |.newer => |      |.newer => | tail |\n*      |  A   |          |  B   |          |  C   |          |  D   |\n*      |______| <= older.|______| <= older.|______| <= older.|______|\n*\n*  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n*/\nfunction MakeLRUCache(limit) {\n    return new LRUCache(limit);\n}\nfunction LRUCache(limit) {\n    // Current size of the cache. (Read-only).\n    this.size = 0;\n    // Maximum number of items this cache can hold.\n    this.limit = limit;\n    this._keymap = {};\n}\n/**\n * Put <value> into the cache associated with <key>. Returns the entry which was\n * removed to make room for the new entry. Otherwise undefined is returned\n * (i.e. if there was enough room already).\n */\nLRUCache.prototype.put = function (key, value) {\n    var entry = { key: key, value: value };\n    // Note: No protection agains replacing, and thus orphan entries. By design.\n    this._keymap[key] = entry;\n    if (this.tail) {\n        // link previous tail to the new tail (entry)\n        this.tail.newer = entry;\n        entry.older = this.tail;\n    }\n    else {\n        // we're first in -- yay\n        this.head = entry;\n    }\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.tail = entry;\n    if (this.size === this.limit) {\n        // we hit the limit -- remove the head\n        return this.shift();\n    }\n    else {\n        // increase the size counter\n        this.size++;\n    }\n};\n/**\n * Purge the least recently used (oldest) entry from the cache. Returns the\n * removed entry or undefined if the cache was empty.\n *\n * If you need to perform any form of finalization of purged items, this is a\n * good place to do it. Simply override/replace this function:\n *\n *   var c = new LRUCache(123);\n *   c.shift = function() {\n *     var entry = LRUCache.prototype.shift.call(this);\n *     doSomethingWith(entry);\n *     return entry;\n *   }\n */\nLRUCache.prototype.shift = function () {\n    // todo: handle special case when limit == 1\n    var entry = this.head;\n    if (entry) {\n        if (this.head.newer) {\n            this.head = this.head.newer;\n            this.head.older = undefined;\n        }\n        else {\n            this.head = undefined;\n        }\n        // Remove last strong reference to <entry> and remove links from the purged\n        // entry being returned:\n        entry.newer = entry.older = undefined;\n        // delete is slow, but we need to do this to avoid uncontrollable growth:\n        delete this._keymap[entry.key];\n    }\n    console.log('purging ', entry.key);\n    return entry;\n};\n/**\n * Get and register recent use of <key>. Returns the value associated with <key>\n * or undefined if not in cache.\n */\nLRUCache.prototype.get = function (key, returnEntry) {\n    // First, find our cache entry\n    var entry = this._keymap[key];\n    if (entry === undefined)\n        return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    if (entry === this.tail) {\n        // Already the most recently used entry, so no need to update the list\n        return returnEntry ? entry : entry.value;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry.newer) {\n        if (entry === this.head)\n            this.head = entry.newer;\n        entry.newer.older = entry.older; // C <-- E.\n    }\n    if (entry.older)\n        entry.older.newer = entry.newer; // C. --> E\n    entry.newer = undefined; // D --x\n    entry.older = this.tail; // D. --> E\n    if (this.tail)\n        this.tail.newer = entry; // E. <-- D\n    this.tail = entry;\n    return returnEntry ? entry : entry.value;\n};\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n/**\n * Check if <key> is in the cache without registering recent use. Feasible if\n * you do not want to chage the state of the cache, but only \"peek\" at it.\n * Returns the entry associated with <key> if found, or undefined if not found.\n */\nLRUCache.prototype.find = function (key) {\n    return this._keymap[key];\n};\n/**\n * Update the value of entry with <key>. Returns the old value, or undefined if\n * entry was not in the cache.\n */\nLRUCache.prototype.set = function (key, value) {\n    var oldvalue;\n    var entry = this.get(key, true);\n    if (entry) {\n        oldvalue = entry.value;\n        entry.value = value;\n    }\n    else {\n        oldvalue = this.put(key, value);\n        if (oldvalue)\n            oldvalue = oldvalue.value;\n    }\n    return oldvalue;\n};\n/**\n * Remove entry <key> from cache and return its value. Returns undefined if not\n * found.\n */\nLRUCache.prototype.remove = function (key) {\n    var entry = this._keymap[key];\n    if (!entry)\n        return;\n    delete this._keymap[entry.key]; // need to do delete unfortunately\n    if (entry.newer && entry.older) {\n        // relink the older entry with the newer entry\n        entry.older.newer = entry.newer;\n        entry.newer.older = entry.older;\n    }\n    else if (entry.newer) {\n        // remove the link to us\n        entry.newer.older = undefined;\n        // link the newer entry to head\n        this.head = entry.newer;\n    }\n    else if (entry.older) {\n        // remove the link to us\n        entry.older.newer = undefined;\n        // link the newer entry to head\n        this.tail = entry.older;\n    }\n    else { // if(entry.older === undefined && entry.newer === undefined) {\n        this.head = this.tail = undefined;\n    }\n    this.size--;\n    return entry.value;\n};\n/** Removes all entries */\nLRUCache.prototype.removeAll = function () {\n    // This should be safe, as we never expose strong refrences to the outside\n    this.head = this.tail = undefined;\n    this.size = 0;\n    this._keymap = {};\n};\n/**\n * Return an array containing all keys of entries stored in the cache object, in\n * arbitrary order.\n */\nif (typeof Object.keys === 'function') {\n    LRUCache.prototype.keys = function () { return Object.keys(this._keymap); };\n}\nelse {\n    LRUCache.prototype.keys = function () {\n        var keys = [];\n        for (var k in this._keymap)\n            keys.push(k);\n        return keys;\n    };\n}\n/**\n * Call `fun` for each entry. Starting with the newest entry if `desc` is a true\n * value, otherwise starts with the oldest (head) enrty and moves towards the\n * tail.\n *\n * `fun` is called with 3 arguments in the context `context`:\n *   `fun.call(context, Object key, Object value, LRUCache self)`\n */\nLRUCache.prototype.forEach = function (fun, context, desc) {\n    var entry;\n    if (context === true) {\n        desc = true;\n        context = undefined;\n    }\n    else if (typeof context !== 'object')\n        context = this;\n    if (desc) {\n        entry = this.tail;\n        while (entry) {\n            fun.call(context, entry.key, entry.value, this);\n            entry = entry.older;\n        }\n    }\n    else {\n        entry = this.head;\n        while (entry) {\n            fun.call(context, entry.key, entry.value, this);\n            entry = entry.newer;\n        }\n    }\n};\n/** Returns a JSON (array) representation */\n//LRUCache.prototype.toJSON = function () {\n//    var s: IEntry[] = [], entry = this.head;\n//    while (entry) {\n//        s.push({ key: entry.key.toJSON(), value: entry.value.toJSON() });\n//        entry = entry.newer;\n//    }\n//    return s;\n//};\n/** Returns a String representation */\nLRUCache.prototype.toString = function () {\n    var s = '', entry = this.head;\n    while (entry) {\n        s += String(entry.key) + ':' + entry.value;\n        entry = entry.newer;\n        if (entry)\n            s += ' < ';\n    }\n    return s;\n};\n// Export ourselves\n//if (typeof this === 'object') this.LRUCache = LRUCache;\n\nvar DefaultApiCache = /** @class */ (function () {\n    function DefaultApiCache(limit) {\n        if (limit === void 0) { limit = 1000; }\n        this.lru = MakeLRUCache(limit);\n    }\n    DefaultApiCache.prototype.isExpired = function (key) {\n        var value = this.lru.get(key, false);\n        if (value) {\n            return value.expiredIn !== 0 && value.expiredIn < Date.now();\n        }\n        else {\n            return false;\n        }\n    };\n    DefaultApiCache.prototype.get = function (key, cb) {\n        var value = this.lru.get(key, false);\n        if (value && !this.isExpired(key)) {\n            cb(null, value.data);\n        }\n        else {\n            cb && cb(null);\n        }\n    };\n    DefaultApiCache.prototype.set = function (key, value, ttl, cb) {\n        this.lru.remove(key);\n        this.lru.put(key, {\n            data: value,\n            expiredIn: ttl ? (Date.now() + (ttl * 1000)) : 0,\n        });\n        cb && cb(null);\n    };\n    DefaultApiCache.prototype.remove = function (key, cb) {\n        this.lru.remove(key);\n        cb && cb(null);\n    };\n    DefaultApiCache.prototype.clear = function (cb) {\n        this.lru.removeAll();\n        cb && cb(null);\n    };\n    return DefaultApiCache;\n}());\n\nfunction fetchRequest(url, options, callback) {\n    var fetchOptions = {\n        headers: {\n            Accept: 'application/json',\n        },\n    };\n    if (options && options.proxyAgent) {\n        fetchOptions.agent = options.proxyAgent;\n    }\n    // can't use number because of NodeJS globals included\n    var timeoutId;\n    var fetchPromise = crossFetch(url, fetchOptions);\n    var promise = options.timeoutInMs ? Promise.race([\n        fetchPromise,\n        new Promise(function (_, reject) {\n            timeoutId = setTimeout(function () { return reject(new Error(url + \" response timeout\")); }, options.timeoutInMs);\n        })\n    ]) : fetchPromise;\n    promise.then(function (resp) {\n        clearTimeout(timeoutId);\n        if (~~(resp.status / 100 !== 2)) {\n            /**\n             * @description\n             * drain the resp before throwing an error to prevent memory leaks\n             * @link https://github.com/bitinn/node-fetch/issues/83\n             */\n            return resp.text().then(function () {\n                var e = new Error(\"Unexpected status code [\" + resp.status + \"] on URL \" + url);\n                e.status = resp.status;\n                throw e;\n            });\n        }\n        return resp.json().then(function (result) {\n            var cacheControl = resp.headers.get('cache-control');\n            var parsedCacheControl = cacheControl ? /max-age=(\\d+)/.exec(cacheControl) : null;\n            var ttl = parsedCacheControl ? parseInt(parsedCacheControl[1], 10) : undefined;\n            callback(null, result, resp, ttl);\n        });\n    }).catch(function (err) {\n        clearTimeout(timeoutId);\n        callback(err);\n    });\n}\nvar DefaultRequestHandler = /** @class */ (function () {\n    function DefaultRequestHandler(options) {\n        this.options = options || {};\n    }\n    DefaultRequestHandler.prototype.request = function (url, callback) {\n        fetchRequest(url, this.options, callback);\n    };\n    return DefaultRequestHandler;\n}());\n\nvar HttpClient = /** @class */ (function () {\n    function HttpClient(requestHandler, cache, proxyAgent, timeoutInMs) {\n        this.requestHandler = requestHandler || new DefaultRequestHandler({ proxyAgent: proxyAgent, timeoutInMs: timeoutInMs });\n        this.cache = cache || new DefaultApiCache();\n    }\n    HttpClient.prototype.request = function (url, callback) {\n        this.requestHandler.request(url, function (err, result, xhr, ttl) {\n            if (err) {\n                callback && callback(err, null, xhr, ttl);\n            }\n            else if (result) {\n                callback && callback(null, result, xhr, ttl);\n            }\n        });\n    };\n    /**\n     * Fetch a URL corresponding to a query, and parse the response as a Response object\n     */\n    HttpClient.prototype.cachedRequest = function (url, maybeOptions) {\n        var _this = this;\n        var options = maybeOptions || {};\n        var run = function (cb) {\n            var cacheKey = options.cacheKey || url;\n            _this.cache.get(cacheKey, function (cacheGetError, cacheGetValue) {\n                if (cacheGetError || cacheGetValue) {\n                    cb(cacheGetError, cacheGetValue);\n                }\n                else {\n                    _this.request(url, function (fetchError, fetchValue, _, ttlReq) {\n                        if (fetchError) {\n                            cb(fetchError, null);\n                        }\n                        else {\n                            var ttl = ttlReq || options.ttl;\n                            if (ttl) {\n                                _this.cache.set(cacheKey, fetchValue, ttl, cb);\n                            }\n                            cb(null, fetchValue);\n                        }\n                    });\n                }\n            });\n        };\n        return new Promise(function (resolve, reject) {\n            run(function (err, value) {\n                if (err)\n                    reject(err);\n                if (value)\n                    resolve(value);\n            });\n        });\n    };\n    return HttpClient;\n}());\n\nfunction separator(url) {\n    return url.indexOf('?') > -1 ? '&' : '?';\n}\nvar Api = /** @class */ (function () {\n    function Api(url, options) {\n        this.options = options || {};\n        this.url = url;\n        if (this.options.accessToken) {\n            var accessTokenParam = \"access_token=\" + this.options.accessToken;\n            this.url += separator(url) + accessTokenParam;\n        }\n        if (this.options.routes) {\n            this.url += separator(url) + (\"routes=\" + encodeURIComponent(JSON.stringify(this.options.routes)));\n        }\n        this.apiDataTTL = this.options.apiDataTTL || 5;\n        this.httpClient = new HttpClient(this.options.requestHandler, this.options.apiCache, this.options.proxyAgent, this.options.timeoutInMs);\n    }\n    /**\n     * Fetches data used to construct the api client, from cache if it's\n     * present, otherwise from calling the prismic api endpoint (which is\n     * then cached).\n     */\n    Api.prototype.get = function (cb) {\n        var _this = this;\n        return this.httpClient.cachedRequest(this.url, { ttl: this.apiDataTTL }).then(function (data) {\n            var resolvedApi = new ResolvedApi(data, _this.httpClient, _this.options);\n            cb && cb(null, resolvedApi);\n            return resolvedApi;\n        }).catch(function (error) {\n            cb && cb(error);\n            throw error;\n        });\n    };\n    return Api;\n}());\n\nvar DefaultClient = /** @class */ (function () {\n    function DefaultClient(url, options) {\n        this.api = new Api(url, options);\n    }\n    DefaultClient.prototype.getApi = function () {\n        return this.api.get();\n    };\n    DefaultClient.prototype.everything = function () {\n        return this.form('everything');\n    };\n    DefaultClient.prototype.form = function (formId) {\n        return new LazySearchForm(formId, this.api);\n    };\n    DefaultClient.prototype.query = function (q, optionsOrCallback, cb) {\n        return this.getApi().then(function (api) { return api.query(q, optionsOrCallback, cb); });\n    };\n    DefaultClient.prototype.queryFirst = function (q, optionsOrCallback, cb) {\n        return this.getApi().then(function (api) { return api.queryFirst(q, optionsOrCallback, cb); });\n    };\n    DefaultClient.prototype.getByID = function (id, options, cb) {\n        return this.getApi().then(function (api) { return api.getByID(id, options, cb); });\n    };\n    DefaultClient.prototype.getByIDs = function (ids, options, cb) {\n        return this.getApi().then(function (api) { return api.getByIDs(ids, options, cb); });\n    };\n    DefaultClient.prototype.getByUID = function (type, uid, options, cb) {\n        return this.getApi().then(function (api) { return api.getByUID(type, uid, options, cb); });\n    };\n    DefaultClient.prototype.getSingle = function (type, options, cb) {\n        return this.getApi().then(function (api) { return api.getSingle(type, options, cb); });\n    };\n    DefaultClient.prototype.getBookmark = function (bookmark, options, cb) {\n        return this.getApi().then(function (api) { return api.getBookmark(bookmark, options, cb); });\n    };\n    DefaultClient.prototype.previewSession = function (token, linkResolver, defaultUrl, cb) {\n        return this.getApi().then(function (api) { return api.previewSession(token, linkResolver, defaultUrl, cb); });\n    };\n    DefaultClient.prototype.getPreviewResolver = function (token, documentId) {\n        var _this = this;\n        var getDocById = function (documentId, maybeOptions) { return _this.getApi().then(function (api) {\n            return api.getByID(documentId, maybeOptions);\n        }); };\n        return createPreviewResolver(token, documentId, getDocById);\n    };\n    DefaultClient.getApi = function (url, options) {\n        var api = new Api(url, options);\n        return api.get();\n    };\n    return DefaultClient;\n}());\n\nvar index = {\n    experimentCookie: EXPERIMENT_COOKIE,\n    previewCookie: PREVIEW_COOKIE,\n    Predicates: Predicates,\n    Experiments: Experiments,\n    Api: Api,\n    client: client,\n    getApi: getApi,\n    api: api,\n};\nfunction client(url, options) {\n    return new DefaultClient(url, options);\n}\nfunction getApi(url, options) {\n    return DefaultClient.getApi(url, options);\n}\nfunction api(url, options) {\n    return getApi(url, options);\n}\n\nexport default index;\n//# sourceMappingURL=prismic-javascript.mjs.map\n","module.exports = (__webpack_require__(/*! dll-reference dll_ef0ff7c60362f24a921f */ \"dll-reference dll_ef0ff7c60362f24a921f\"))(\"./node_modules/react/index.js\");","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import Prismic from \"prismic-javascript\";\nimport { useEffect, useState } from \"react\";\n\nfunction App({ Component, pageProps }) {\n  const [releases, setReleasesData] = useState(null);\n  const [dataIsLoaded, setDataIsLoaded] = useState(false);\n  const apiEndpoint = \"https://elis-records.prismic.io/api/v2\";\n  const accessToken = \"\";\n  const Client = Prismic.client(apiEndpoint, { accessToken });\n  useEffect(() => {\n    const fetchData = async () => {\n      const response = await Client.query(\n        Prismic.Predicates.at(\"document.type\", \"release\"),\n        { orderings: \"[my.release.release-date desc]\" }\n      );\n      if (response) {\n        setReleasesData(response.results);\n        setDataIsLoaded(true);\n      }\n    };\n    fetchData();\n  }, []);\n  return <Component releases={releases} dataIsLoaded={dataIsLoaded} />;\n}\n\n// Only uncomment this method if you have blocking data requirements for\n// every single page in your application. This disables the ability to\n// perform automatic static optimization, causing every page in your app to\n// be server-side rendered.\n//\n// MyApp.getInitialProps = async (appContext) => {\n//   // calls page's `getInitialProps` and fills `appProps.pageProps`\n//   const appProps = await App.getInitialProps(appContext);\n//\n//   return { ...appProps }\n// }\n\nexport default App;\n","module.exports = dll_ef0ff7c60362f24a921f;"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACziBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7vCA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACrtBA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAJA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;ACrCA;;;;A","sourceRoot":""}